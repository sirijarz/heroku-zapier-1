"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("./util");
exports.FREE_ATOM = util_1.asciiToU32Be('free');
exports.JUNK_ATOM = util_1.asciiToU32Be('junk');
exports.MDAT_ATOM = util_1.asciiToU32Be('mdat');
exports.MOOV_ATOM = util_1.asciiToU32Be('moov');
exports.PNOT_ATOM = util_1.asciiToU32Be('pnot');
exports.SKIP_ATOM = util_1.asciiToU32Be('skip');
exports.WIDE_ATOM = util_1.asciiToU32Be('wide');
exports.PICT_ATOM = util_1.asciiToU32Be('PICT');
exports.FTYP_ATOM = util_1.asciiToU32Be('ftyp');
exports.UUID_ATOM = util_1.asciiToU32Be('uuid');
exports.CMOV_ATOM = util_1.asciiToU32Be('cmov');
exports.TRAK_ATOM = util_1.asciiToU32Be('trak');
exports.MDIA_ATOM = util_1.asciiToU32Be('mdia');
exports.MINF_ATOM = util_1.asciiToU32Be('minf');
exports.STBL_ATOM = util_1.asciiToU32Be('stbl');
exports.STCO_ATOM = util_1.asciiToU32Be('stco');
exports.CO64_ATOM = util_1.asciiToU32Be('co64');
exports.ATOM_PREAMBLE_SIZE = BigInt(8);
exports.MAX_FTYP_ATOM_SIZE = BigInt(1048576);
function parseAtoms(infile, depth = 0) {
    const atoms = [];
    const cur = {
        pos: BigInt(0)
    };
    const len = BigInt(infile.byteLength);
    while (cur.pos < len) {
        if (len - cur.pos < 8) {
            break;
        }
        let fwd; // forward-seek counter
        let atomSize = BigInt(util_1.readU32(cur, infile));
        const atomType = util_1.readU32(cur, infile);
        if (Number(atomSize) === 1) {
            // 64-bit atom size
            atomSize = util_1.readU64(cur, infile);
            if (atomSize > BigInt(Number.MAX_SAFE_INTEGER)) {
                throw new Error(`"${atomType}" atom size is larger than MAX_SAFE_INTEGER!`);
            }
            fwd = atomSize - exports.ATOM_PREAMBLE_SIZE * BigInt(2);
        }
        else {
            fwd = atomSize - exports.ATOM_PREAMBLE_SIZE;
        }
        const endOfAtom = cur.pos + fwd;
        const subatoms = Buffer.from(infile.slice(Number(cur.pos), Number(endOfAtom)));
        const data = hasSubatoms(atomType) && depth < 10 ? parseAtoms(subatoms, depth + 1) : subatoms;
        cur.pos = endOfAtom;
        if (depth === 0 && !isQtAtom(atomType)) {
            throw new Error(`Non-QT top-level atom found: ${util_1.u32BeToAscii(atomType)}`);
        }
        atoms.push({
            kind: util_1.u32BeToAscii(atomType),
            size: atomSize,
            data
        });
    }
    return atoms;
}
exports.parseAtoms = parseAtoms;
function recurseFlattenAtoms(atoms, depth = 0) {
    const buffers = [];
    for (const atom of atoms) {
        if (!Buffer.isBuffer(atom.data)) {
            atom.data = recurseFlattenAtoms(atom.data, depth + 1);
        }
        const u64Size = Number(exports.ATOM_PREAMBLE_SIZE) + atom.data.byteLength > 2 ** 32 - 1;
        let header;
        if (u64Size) {
            const u64Preamble = Number(exports.ATOM_PREAMBLE_SIZE) * 2;
            header = Buffer.alloc(u64Preamble);
            header.writeUInt32BE(1, 0);
            header.writeUInt32BE(util_1.asciiToU32Be(atom.kind), 4);
            const newSize = u64Preamble + atom.data.byteLength;
            header.writeUInt32BE((newSize >> 32) & 0xffffffff, 8);
            header.writeUInt32BE(newSize & 0xffffffff, 12);
        }
        else {
            header = Buffer.alloc(Number(exports.ATOM_PREAMBLE_SIZE));
            const newSize = Number(exports.ATOM_PREAMBLE_SIZE) + atom.data.byteLength;
            header.writeUInt32BE(newSize, 0);
            header.writeUInt32BE(util_1.asciiToU32Be(atom.kind), 4);
        }
        const buf = Buffer.concat([header, atom.data]);
        buffers.push(buf);
    }
    return Buffer.concat(buffers);
}
exports.recurseFlattenAtoms = recurseFlattenAtoms;
function traverseAtoms(atoms, callback) {
    for (const atom of atoms) {
        if (!Buffer.isBuffer(atom.data)) {
            traverseAtoms(atom.data, callback);
        }
        callback(atom);
    }
}
exports.traverseAtoms = traverseAtoms;
function isQtAtom(atomType) {
    return [
        exports.FREE_ATOM,
        exports.JUNK_ATOM,
        exports.MDAT_ATOM,
        exports.MOOV_ATOM,
        exports.PNOT_ATOM,
        exports.SKIP_ATOM,
        exports.WIDE_ATOM,
        exports.PICT_ATOM,
        exports.FTYP_ATOM,
        exports.UUID_ATOM,
        exports.CMOV_ATOM,
        exports.TRAK_ATOM,
        exports.MDIA_ATOM,
        exports.MINF_ATOM,
        exports.STBL_ATOM,
        exports.STCO_ATOM,
        exports.CO64_ATOM
    ].includes(atomType);
}
exports.isQtAtom = isQtAtom;
function hasSubatoms(atomType) {
    return [exports.MOOV_ATOM, exports.TRAK_ATOM, exports.MDIA_ATOM, exports.MINF_ATOM, exports.STBL_ATOM].includes(atomType);
}
exports.hasSubatoms = hasSubatoms;
//# sourceMappingURL=atom.js.map