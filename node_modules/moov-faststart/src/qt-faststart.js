"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const atom_1 = require("./atom");
const update_chunk_offsets_1 = require("./update-chunk-offsets");
/**
 * Enables "faststart" for QuickTime files so that they can be streamed.
 *
 * @param infile QT/mp4 to faststart
 * @returns Faststarted QT/mp4
 */
function faststart(infile, options = {}) {
    const file = Buffer.from(infile);
    const atoms = atom_1.parseAtoms(file);
    const mdatIndex = atoms.findIndex(atom => atom.kind === 'mdat');
    if (mdatIndex === -1) {
        throw new Error(`No mdat atom found!`);
    }
    const moovIndex = atoms.findIndex(atom => atom.kind === 'moov');
    if (moovIndex === -1) {
        throw new Error(`No moov atom found!`);
    }
    if (moovIndex < mdatIndex) {
        // moov atom is already up front!
        return file;
    }
    const faststarted = sortFaststartAtoms(atoms, options);
    return atom_1.recurseFlattenAtoms(faststarted);
}
exports.default = faststart;
/**
 * Sorts an array of QT atoms so that the first two atoms are `ftyp`, then `moov`.
 * Additionally updates all chunk offsets (`stco`/`co64` atoms) in `moov`.
 *
 * @param atoms QT atoms to sort
 */
function sortFaststartAtoms(atoms, options) {
    const faststarted = [];
    const ftyp = atoms.find(atom => atom.kind === 'ftyp');
    if (!ftyp) {
        throw new Error('Missing ftyp atom!');
    }
    if (ftyp.size > atom_1.MAX_FTYP_ATOM_SIZE) {
        throw new Error(`ftyp atom is greater than ${atom_1.MAX_FTYP_ATOM_SIZE}`);
    }
    const moov = atoms.find(atom => atom.kind === 'moov');
    update_chunk_offsets_1.default(moov, options);
    faststarted.push(ftyp, moov);
    const rest = atoms.filter(atom => !['ftyp', 'moov'].includes(atom.kind));
    faststarted.push(...rest);
    return faststarted;
}
exports.sortFaststartAtoms = sortFaststartAtoms;
//# sourceMappingURL=qt-faststart.js.map